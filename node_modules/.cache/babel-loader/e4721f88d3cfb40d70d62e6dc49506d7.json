{"ast":null,"code":"import { useEffect, useState } from 'react';\n\nfunction useIntersectionObserver(elementRef, _ref) {\n  let {\n    threshold = 0,\n    root = null,\n    rootMargin = '0%',\n    freezeOnceVisible = false\n  } = _ref;\n  const [entry, setEntry] = useState();\n  const frozen = entry?.isIntersecting && freezeOnceVisible;\n\n  const updateEntry = _ref2 => {\n    let [entry] = _ref2;\n    setEntry(entry);\n  };\n\n  useEffect(() => {\n    const node = elementRef?.current;\n    const hasIOSupport = !!window.IntersectionObserver;\n    if (!hasIOSupport || frozen || !node) return;\n    const observerParams = {\n      threshold,\n      root,\n      rootMargin\n    };\n    const observer = new IntersectionObserver(updateEntry, observerParams);\n    observer.observe(node);\n    return () => observer.disconnect();\n  }, [elementRef, JSON.stringify(threshold), root, rootMargin, frozen]);\n  return entry;\n}\n\nexport default useIntersectionObserver;","map":{"version":3,"mappings":"AAAA,SAAoBA,SAApB,EAA+BC,QAA/B,QAA+C,OAA/C;;AAMA,SAASC,uBAAT,CACEC,UADF,QAOS;AAAA,MALP;AACEC,aAAS,GAAG,CADd;AAEEC,QAAI,GAAG,IAFT;AAGEC,cAAU,GAAG,IAHf;AAIEC,qBAAiB,GAAG;AAJtB,GAKO;AAEP,QAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBR,QAAQ,EAAlC;AAEA,QAAMS,MAAM,GAAGF,KAAK,EAAEG,cAAP,IAAyBJ,iBAAxC;;AAEA,QAAMK,WAAW,GAAG,SAA+C;AAAA,QAA9C,CAACJ,KAAD,CAA8C;AACjEC,YAAQ,CAACD,KAAD,CAAR;AACD,GAFD;;AAIAR,WAAS,CAAC,MAAK;AACb,UAAMa,IAAI,GAAGV,UAAU,EAAEW,OAAzB;AACA,UAAMC,YAAY,GAAG,CAAC,CAACC,MAAM,CAACC,oBAA9B;AAEA,QAAI,CAACF,YAAD,IAAiBL,MAAjB,IAA2B,CAACG,IAAhC,EAAsC;AAEtC,UAAMK,cAAc,GAAG;AAAEd,eAAF;AAAaC,UAAb;AAAmBC;AAAnB,KAAvB;AACA,UAAMa,QAAQ,GAAG,IAAIF,oBAAJ,CAAyBL,WAAzB,EAAsCM,cAAtC,CAAjB;AAEAC,YAAQ,CAACC,OAAT,CAAiBP,IAAjB;AAEA,WAAO,MAAMM,QAAQ,CAACE,UAAT,EAAb;AAGD,GAdQ,EAcN,CAAClB,UAAD,EAAamB,IAAI,CAACC,SAAL,CAAenB,SAAf,CAAb,EAAwCC,IAAxC,EAA8CC,UAA9C,EAA0DI,MAA1D,CAdM,CAAT;AAgBA,SAAOF,KAAP;AACD;;AAED,eAAeN,uBAAf","names":["useEffect","useState","useIntersectionObserver","elementRef","threshold","root","rootMargin","freezeOnceVisible","entry","setEntry","frozen","isIntersecting","updateEntry","node","current","hasIOSupport","window","IntersectionObserver","observerParams","observer","observe","disconnect","JSON","stringify"],"sources":["/Users/hyeonminsong/developer/Three.js/portfolio-inner-site/node_modules/usehooks-ts/src/useIntersectionObserver/useIntersectionObserver.ts"],"sourcesContent":["import { RefObject, useEffect, useState } from 'react'\n\ninterface Args extends IntersectionObserverInit {\n  freezeOnceVisible?: boolean\n}\n\nfunction useIntersectionObserver(\n  elementRef: RefObject<Element>,\n  {\n    threshold = 0,\n    root = null,\n    rootMargin = '0%',\n    freezeOnceVisible = false,\n  }: Args,\n): IntersectionObserverEntry | undefined {\n  const [entry, setEntry] = useState<IntersectionObserverEntry>()\n\n  const frozen = entry?.isIntersecting && freezeOnceVisible\n\n  const updateEntry = ([entry]: IntersectionObserverEntry[]): void => {\n    setEntry(entry)\n  }\n\n  useEffect(() => {\n    const node = elementRef?.current // DOM Ref\n    const hasIOSupport = !!window.IntersectionObserver\n\n    if (!hasIOSupport || frozen || !node) return\n\n    const observerParams = { threshold, root, rootMargin }\n    const observer = new IntersectionObserver(updateEntry, observerParams)\n\n    observer.observe(node)\n\n    return () => observer.disconnect()\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [elementRef, JSON.stringify(threshold), root, rootMargin, frozen])\n\n  return entry\n}\n\nexport default useIntersectionObserver\n"]},"metadata":{},"sourceType":"module"}