{"ast":null,"code":"import { useEffect, useReducer, useRef } from 'react';\n\nfunction useFetch(url, options) {\n  const cache = useRef({});\n  const cancelRequest = useRef(false);\n  const initialState = {\n    error: undefined,\n    data: undefined\n  };\n\n  const fetchReducer = (state, action) => {\n    switch (action.type) {\n      case 'loading':\n        return { ...initialState\n        };\n\n      case 'fetched':\n        return { ...initialState,\n          data: action.payload\n        };\n\n      case 'error':\n        return { ...initialState,\n          error: action.payload\n        };\n\n      default:\n        return state;\n    }\n  };\n\n  const [state, dispatch] = useReducer(fetchReducer, initialState);\n  useEffect(() => {\n    if (!url) return;\n\n    const fetchData = async () => {\n      dispatch({\n        type: 'loading'\n      });\n\n      if (cache.current[url]) {\n        dispatch({\n          type: 'fetched',\n          payload: cache.current[url]\n        });\n        return;\n      }\n\n      try {\n        const response = await fetch(url, options);\n\n        if (!response.ok) {\n          throw new Error(response.statusText);\n        }\n\n        const data = await response.json();\n        cache.current[url] = data;\n        if (cancelRequest.current) return;\n        dispatch({\n          type: 'fetched',\n          payload: data\n        });\n      } catch (error) {\n        if (cancelRequest.current) return;\n        dispatch({\n          type: 'error',\n          payload: error\n        });\n      }\n    };\n\n    void fetchData();\n    return () => {\n      cancelRequest.current = true;\n    };\n  }, [url]);\n  return state;\n}\n\nexport default useFetch;","map":{"version":3,"mappings":"AAAA,SAASA,SAAT,EAAoBC,UAApB,EAAgCC,MAAhC,QAA8C,OAA9C;;AAeA,SAASC,QAAT,CAA+BC,GAA/B,EAA6CC,OAA7C,EAAkE;AAChE,QAAMC,KAAK,GAAGJ,MAAM,CAAW,EAAX,CAApB;AAGA,QAAMK,aAAa,GAAGL,MAAM,CAAU,KAAV,CAA5B;AAEA,QAAMM,YAAY,GAAa;AAC7BC,SAAK,EAAEC,SADsB;AAE7BC,QAAI,EAAED;AAFuB,GAA/B;;AAMA,QAAME,YAAY,GAAG,CAACC,KAAD,EAAkBC,MAAlB,KAAiD;AACpE,YAAQA,MAAM,CAACC,IAAf;AACE,WAAK,SAAL;AACE,eAAO,EAAE,GAAGP;AAAL,SAAP;;AACF,WAAK,SAAL;AACE,eAAO,EAAE,GAAGA,YAAL;AAAmBG,cAAI,EAAEG,MAAM,CAACE;AAAhC,SAAP;;AACF,WAAK,OAAL;AACE,eAAO,EAAE,GAAGR,YAAL;AAAmBC,eAAK,EAAEK,MAAM,CAACE;AAAjC,SAAP;;AACF;AACE,eAAOH,KAAP;AARJ;AAUD,GAXD;;AAaA,QAAM,CAACA,KAAD,EAAQI,QAAR,IAAoBhB,UAAU,CAACW,YAAD,EAAeJ,YAAf,CAApC;AAEAR,WAAS,CAAC,MAAK;AAEb,QAAI,CAACI,GAAL,EAAU;;AAEV,UAAMc,SAAS,GAAG,YAAW;AAC3BD,cAAQ,CAAC;AAAEF,YAAI,EAAE;AAAR,OAAD,CAAR;;AAGA,UAAIT,KAAK,CAACa,OAAN,CAAcf,GAAd,CAAJ,EAAwB;AACtBa,gBAAQ,CAAC;AAAEF,cAAI,EAAE,SAAR;AAAmBC,iBAAO,EAAEV,KAAK,CAACa,OAAN,CAAcf,GAAd;AAA5B,SAAD,CAAR;AACA;AACD;;AAED,UAAI;AACF,cAAMgB,QAAQ,GAAG,MAAMC,KAAK,CAACjB,GAAD,EAAMC,OAAN,CAA5B;;AACA,YAAI,CAACe,QAAQ,CAACE,EAAd,EAAkB;AAChB,gBAAM,IAAIC,KAAJ,CAAUH,QAAQ,CAACI,UAAnB,CAAN;AACD;;AAED,cAAMb,IAAI,GAAI,MAAMS,QAAQ,CAACK,IAAT,EAApB;AACAnB,aAAK,CAACa,OAAN,CAAcf,GAAd,IAAqBO,IAArB;AACA,YAAIJ,aAAa,CAACY,OAAlB,EAA2B;AAE3BF,gBAAQ,CAAC;AAAEF,cAAI,EAAE,SAAR;AAAmBC,iBAAO,EAAEL;AAA5B,SAAD,CAAR;AACD,OAXD,CAWE,OAAOF,KAAP,EAAc;AACd,YAAIF,aAAa,CAACY,OAAlB,EAA2B;AAE3BF,gBAAQ,CAAC;AAAEF,cAAI,EAAE,OAAR;AAAiBC,iBAAO,EAAEP;AAA1B,SAAD,CAAR;AACD;AACF,KAzBD;;AA2BA,SAAKS,SAAS,EAAd;AAIA,WAAO,MAAK;AACVX,mBAAa,CAACY,OAAd,GAAwB,IAAxB;AACD,KAFD;AAID,GAvCQ,EAuCN,CAACf,GAAD,CAvCM,CAAT;AAyCA,SAAOS,KAAP;AACD;;AAED,eAAeV,QAAf","names":["useEffect","useReducer","useRef","useFetch","url","options","cache","cancelRequest","initialState","error","undefined","data","fetchReducer","state","action","type","payload","dispatch","fetchData","current","response","fetch","ok","Error","statusText","json"],"sources":["/Users/hyeonminsong/developer/Three.js/portfolio-inner-site/node_modules/usehooks-ts/src/useFetch/useFetch.ts"],"sourcesContent":["import { useEffect, useReducer, useRef } from 'react'\n\ninterface State<T> {\n  data?: T\n  error?: Error\n}\n\ntype Cache<T> = { [url: string]: T }\n\n// discriminated union type\ntype Action<T> =\n  | { type: 'loading' }\n  | { type: 'fetched'; payload: T }\n  | { type: 'error'; payload: Error }\n\nfunction useFetch<T = unknown>(url?: string, options?: RequestInit): State<T> {\n  const cache = useRef<Cache<T>>({})\n\n  // Used to prevent state update if the component is unmounted\n  const cancelRequest = useRef<boolean>(false)\n\n  const initialState: State<T> = {\n    error: undefined,\n    data: undefined,\n  }\n\n  // Keep state logic separated\n  const fetchReducer = (state: State<T>, action: Action<T>): State<T> => {\n    switch (action.type) {\n      case 'loading':\n        return { ...initialState }\n      case 'fetched':\n        return { ...initialState, data: action.payload }\n      case 'error':\n        return { ...initialState, error: action.payload }\n      default:\n        return state\n    }\n  }\n\n  const [state, dispatch] = useReducer(fetchReducer, initialState)\n\n  useEffect(() => {\n    // Do nothing if the url is not given\n    if (!url) return\n\n    const fetchData = async () => {\n      dispatch({ type: 'loading' })\n\n      // If a cache exists for this url, return it\n      if (cache.current[url]) {\n        dispatch({ type: 'fetched', payload: cache.current[url] })\n        return\n      }\n\n      try {\n        const response = await fetch(url, options)\n        if (!response.ok) {\n          throw new Error(response.statusText)\n        }\n\n        const data = (await response.json()) as T\n        cache.current[url] = data\n        if (cancelRequest.current) return\n\n        dispatch({ type: 'fetched', payload: data })\n      } catch (error) {\n        if (cancelRequest.current) return\n\n        dispatch({ type: 'error', payload: error as Error })\n      }\n    }\n\n    void fetchData()\n\n    // Use the cleanup function for avoiding a possibly...\n    // ...state update after the component was unmounted\n    return () => {\n      cancelRequest.current = true\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [url])\n\n  return state\n}\n\nexport default useFetch\n"]},"metadata":{},"sourceType":"module"}